/*
  noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com)

  steps to reproduce:

    1. git clone git@github.com:paulmillr/noble-hashes.git
    2. cd noble-hashes
    3. esbuild ./src/hmac.ts --bundle --platform=neutral --minify

*/
function d(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function y(t,...n){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function f(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");d(t.outputLen),d(t.blockLen)}function p(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}var b=t=>t instanceof Uint8Array;var x=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!x)throw new Error("Non little-endian hardware is not supported");function w(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function h(t){if(typeof t=="string"&&(t=w(t)),!b(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}var a=class{clone(){return this._cloneInto()}},H={}.toString;var u=class extends a{constructor(e,c){super();this.finished=!1;this.destroyed=!1;f(e);let s=h(c);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,r=new Uint8Array(i);r.set(s.length>i?e.create().update(s).digest():s);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=e.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),r.fill(0)}update(e){return p(this),this.iHash.update(e),this}digestInto(e){p(this),y(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});let{oHash:c,iHash:s,finished:i,destroyed:r,blockLen:o,outputLen:l}=this;return e=e,e.finished=i,e.destroyed=r,e.blockLen=o,e.outputLen=l,e.oHash=c._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},g=(t,n,e)=>new u(t,n).update(e).digest();g.create=(t,n)=>new u(t,n);export{u as HMAC,g as hmac};
